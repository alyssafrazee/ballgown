[Please see the README.cufflinks for the original Cufflinks README file.]

This is a modified version of Cufflinks (called "tablemaker" from here on)
which has a new output option which makes the program generate a set of tab 
delimited files providing raw read counts and coverage information 
for the given reference transcripts. These new output files are obtained 
by running the tablemaker program using the -W option which requires 
the -G option specifying the reference transcripts to quantify 
(see Cufflinks' manual about the -G option). Thus, the -W option makes 
tablemaker generate a set of *.ctab files in the output directory, 
as documented below.

Note: apart from the new -W option, tablemaker is functionally identical 
to the Cufflinks v2.1.1 program on which it was based and which provides
the FPKM estimates included in the new output files. However, for other
Cufflinks functions (e.g. transcript assembly) we recommend using
the official Cufflinks version instead.

Usage example:
  tablemaker -qW -G <reference_transcripts> -p6 -o output_dir <read_alignments.bam>

After this command, the ./output_dir/ will also have the new output
files generated by the -W option:

  t_data.ctab  : transcript data, including Cufflinks' estimated
                 coverage and FPKM

  e_data.ctab : read counts and raw coverage info for all exons in
                <reference_transcripts>

  i_data.ctab  : read counts for all introns in <reference_transcripts>

  e2t.ctab : table linking exon IDs to transcript IDs

  i2t.ctab :  table linking intron IDs to transcript IDs

The typical use case of this program would be in the context of running
the Tophat/Cufflinks protocol up to the Cuffmerge stage, which generates
a merged set of reference transcripts + transfrags from all the samples
included in the experiment, and then using tablemaker as shown above,
with the -W option and with -G merged.gtf (the file produced by Cuffmerge),
on every sample .bam file.

t_data.ctab columns: transcript data
-----------------------
t_id - unique numeric ID assigned to the transcript
chr, strand, start, end  : genomic location of the transcript
t_name : literal transcript ID as found in the -G file
num_exons : number of exons for the transcript
length : total exonic length of the transcript
gene_id, gene_name : gene information as found in the -G file
cov, FPKM : transcript coverage and FPKM values as estimated by Cufflinks

e_data.ctab columns: exon data
------------------------
e_id : unique numeric ID assigned to each distinct exon
chr, strand, start, end : genomic location of the exon
rcount : number of reads overlapping the exon
ucount: number of uniquely mapped reads overlapping the exon

mrcount : (float) multi-map corrected number of reads overlapping the
          exon: reads mapped in multiple genomic places will be counted as a
          fractional contribution (1/number_of_mappings)

cov : average base coverage for this exon: simply counting for each
      positions how many reads stack up there, summing these all up for each
      exon base and divided by the exon length

cov_sd : standard deviation for the base coverage

mcov : multi-map corrected mean coverage, same as cov but the base
       coverage contribution is fractional for reads mapped in multiple places
       on the genome (1/number_of_mappings, just like mrcount above)

mcov_sd : standard deviation for the mcov calculation

i_data.ctab columns: intron data
--------------------------------
i_id : unique numeric ID assigned to the intron
chr, strand, start, end : genomic location of the intron
rcount : number of reads supporting the intron
ucount: number of uniquely mapped reads supporting the intron
mrcount : (float) multi-map corrected number of reads whose spliced alignment 
          support the intron, with reads mapped in multiple genomic locations 
          counted as a fractional contribution (1/number_of_mappings)

e2t.ctab and i2t.ctab columns are self-explanatory - they simply map an
exon or an intron to the set of transcripts that include them. By
joining this table with e_data or  i_data by e_id or i_id respectively,
one can easily retrieve all the exons for a specific transcript (t_id).
